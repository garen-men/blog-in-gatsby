path: "/rn-2038"
date: "2019-07-28"
title: "RN2038年问题"
tags: ["Bug"]

> 最近处理了RN一堆的闪退问题，心累，虽然建立了日志监控系统，而且借助了react16的错误边界Error Boundaries实现了兜底界面，但是还是有直接闪退的情况

### 问题现象

![](https://user-gold-cdn.xitu.io/2019/8/22/16cb94ff05837e79?w=425&h=291&f=png&s=33436)
最近有测试指出安卓手机app上（为什么总是安卓🤣）时间选择控件一划到2038年以后并读取值，app会直接闪退，经过原生同学排除，表示不是安卓的问题，是RN的native js线程挂了，需要排查有问题的代码

排查问题时值得注意的是，debug远程开启后就没有问题，连接安卓真机就有问题，其实是由于js引擎不同造成的👇

> JavaScript运行 时使用React Native时，您将在两个环境中运行JavaScript代码：
> 在iOS模拟器和设备上，Android模拟器和设备React Native使用JavaScriptCore，它是为Safari提供动力的JavaScript引擎。在iOS上，由于iOS应用程序中缺少可写的可执行内存，因此JSC不使用JIT。
> 使用Chrome调试时，它会运行Chrome中的所有JavaScript代码，并通过WebSocket与本机代码进行通信。所以你使用的是V8。

简单地说，安卓当前使用的是JSC引擎，实现细节，不常用的原生方法可能有所不同。不过60版本以后可选用[hermes赫尔墨斯](http://www.sohu.com/a/327608204_120190378)

### 问题原因

怀疑是
👉[2038年问题](https://baike.baidu.com/item/2038%E5%B9%B4%E9%97%AE%E9%A2%98/10578442?fr=aladdin)

> 在计算机应用上，2038年问题可能会导致某些软件在2038年无法正常工作。所有使用POSIX时间表示时间的程序都将受其影响，因为它们的时间起点是格林尼治时间1970年1月1日0时0分0秒（这个时间名叫 the Unix Epoch），它们用the Unix Epoch经过的秒数（忽略闰秒）来表示时间。这种时间表示法在类Unix（Unix-like）操作系统上是一个标准，并会影响以其C编程语言开发给其他大部份操作系统使用的软件。在大部分的32位操作系统上，此“time_t”数据模式使用一个有符号32位整数(signed int32)存储计算的秒数。依照此“time_t”标准，在此格式能被表示的最后时间是第2147483647秒（代表格林尼治时间2038年1月19日凌晨03:14:07）。下一秒，即格林尼治时间2038年1月19日凌晨03:14:08，由于32位整型溢出，时间将会被“绕回”（wrap around）成一个负数，变成了第 -2147483648 秒（代表格林尼治时间1901年12月13日20:45:52），造成应用程序发生严重的时间错误，而无法运行。

原生与RN通信也会依赖C++代码写的桥接，RN的js引擎也是多半用C实现的，js某行代码有问题就会导致js线程挂掉，应用闪退

### 定位代码

经过古老但是有效的二分法查找代码方式😂，找到了有问题的代码

```
(new Date(2544695704409)).toLocaleDateString()
"2050/8/21"
// 修改后
moment(new Date(2544695704409)).format('L')；
```

在安卓机上，Date对象原型上挂载的toLocaleDateString方法一过2038年就挂掉了，说明现在跨端的框架还是不够成熟，哪怕RN已经几年了，兼容性问题还是有一些。

### 总结

使用日期对象的时候，直接使用moment.js等成熟的库，尽量不要图省事用原生但是危险的方法。

- `toLocaleDateString`方法在浏览器中实现也各不相同，主流的是返回结果`"2050/8/21"`，但是某些版本的浏览器返回结果是`"2050-8-21"`，
- QQ浏览器低版本未正确实现 Date.prototype.toString()、Date.prototype.getDay()、Date.prototype.getTimezoneOffset()、new Date(Time String)等方法，时区没有按照当地时区取。


所以对于date对象还是要引起一些重视，方法不要乱用。。。